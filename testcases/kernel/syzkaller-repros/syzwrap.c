// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * Copyright (c) 2019 Richard Palethorpe <rpalethorpe@suse.com>
 *
 * Run a single reproducer generated by the Syzkaller fuzzer.
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/prctl.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <pwd.h>

#include "tst_test.h"
#include "tst_taint.h"
#include "tst_safe_stdio.h"

#define SANDBOX_HELP "\n"\
	"-s\t Add some sandboxing around the reproducer. This will prevent some\n"\
	"\t reproducers from creating network devices and thus prevent them from\n"\
	"\t working. However it will also prevent some reproducers from trashing\n"\
	"\t the system using root privileges. Note that you may generate the\n"\
	"\t reproducers with various types of sandboxing built in using\n"\
	"\t syz-reprolist"

static char *dir;
static char *name;
static char *path;

static char *sandbox;

static struct tst_option options[] = {
	{"d:", &dir, "\n-d PATH\t Mandatory directory containing reproducers"},
	{"n:", &name, "-n NAME\t Mandatory executable name of reproducer"},
	{"s", &sandbox, SANDBOX_HELP},
	{NULL, NULL, NULL}
};

static void become_nobody(void)
{
	struct passwd *pw;
	int gid, uid;

	setgroups(0, NULL);

	pw = getpwnam("nobody");
	if (pw) {
		gid = pw->pw_gid;
		uid = pw->pw_uid;
	} else {
		gid = 65534;
		uid = 65534;
	}

	SAFE_SETREGID(gid, gid);
	SAFE_SETREUID(uid, uid);
}

static void setup(void)
{
	tst_taint_init(TST_TAINT_W | TST_TAINT_D | TST_TAINT_L);

	if (!dir)
		tst_brk(TBROK, "No reproducer directory specified");

	if (!name)
		tst_brk(TBROK, "No reproducer name specified");

	tst_res(TINFO, "https://syzkaller.appspot.com/bug?id=%s", name);

	SAFE_ASPRINTF(&path, "%s/%s", dir, name);
	tst_res(TINFO, "%s", path);
}

static void run(void)
{
	unsigned int backoff = 100;
	int rem, status, sent_kill = 0;
	float exec_time_start = (float)tst_timeout_remaining();
	int pid;

	if (sandbox)
		SAFE_UNSHARE(CLONE_NEWPID);

	pid = SAFE_FORK();
	if (!pid) {
		if (sandbox) {
			SAFE_UNSHARE(CLONE_NEWNET);
			become_nobody();
		}

		if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0)) {
			tst_res(TWARN | TERRNO,
				"Failed to set dumpable; won't be able to open /proc/self/*");
		}

		execl(path, name, NULL);
		tst_brk(TBROK | TERRNO, "Failed to exec reproducer");
	}

	while (!waitpid(pid, &status, WNOHANG)) {
		rem = tst_timeout_remaining();

		if (!sent_kill && rem / exec_time_start < 0.5) {
			tst_res(TINFO, "Timeout; killing reproducer");

			TEST(kill(pid, SIGKILL));
			if (TST_RET == -1)
				tst_res(TWARN | TTERRNO, "kill() failed");
			else
				sent_kill = 1;
		}

		usleep(backoff);
		backoff = MIN(2 * backoff, 1000000);
	}

	if (tst_taint_check()) {
		tst_res(TFAIL, "Kernel is tainted");
	} else {
		tst_res(TPASS, "Kernel is not tainted");
	}
}

static struct tst_test test = {
	.setup = setup,
	.test_all = run,
	.options = options,
	.needs_tmpdir = 1,
	.forks_child = 1,
	.timeout = 20
};
